一.使用前提
1.编译条件：
要使用gdb，则在编译的时候需要加上 -g选项
加了-g才有调试信息，例如一个加了调试信息的可执行程序，InvokeTestServer,执行:
gdb InvokeTestServer
可看到:Reading symbols from /home/chenweixian/TestTars/TestApp/InvokeTestServer/InvokeTestServer...done.
如果不加-g,则执行时的提示是这样的:
Reading symbols from /home/chenweixian/TestTars/TestApp/InvokeTestServer/InvokeTestServer...(no debugging symbols found)...done.

加了调试信息的可执行程序体积会变大，执行效率也会一定程度降低，可用strip命令去掉调试信息：
strip InvokeTestServer

在实际生成调试程序时，一般不仅要加上 -g 选项，也建议关闭编译器的程序优化选项。
编译器的程序优化选项一般有五个级别，从 O0 ~ O4 （ 注意第一个 O0 ，是字母 O 加上数字 0 ）， 
O0 表示不优化，从 O1 ~ O4 优化级别越来越高，O4 最高。
这样做的目的是为了调试的时候，符号文件显示的调试变量等能与源代码完全对应起来。

例如tars的makefile：
CFLAGS      += -std=c++11 -g -O2 -Wno-deprecated -Wall


2.调试codefile运行环境设置：
查看是否开启生成codefile文件:
ulimit -c 或者 ulimit -a,如果core file size为0则不会生成codefile文件

（1）.core文件生成开关 
ulimit -c unlimited 不限制生成core文件大小 
ulimit -c 0 关闭core文件生成开关 
ulimit -c 1024 限定生成core文件的大小为1024
这种修改是临时性的，关闭这个会话后又会变成默认值0了
如果要永久的修改，需要把这条命令加到/etc/profile文件中

（2）.core文件的命名规则 
/proc/sys/kernel/core_uses_pid 1 表示使用procid命名，0表示不使用 
/proc/sys/kernel/core_pattern 可以设置格式化的 core 文件保存位置或文件名 
echo “/opt/corefile/core-%e-%p-%t” > /proc/sys/kernel/core_pattern 
将会控制所产生的 core 文件会存放到 /corefile 目录下，产生的文件名为 core- 命令名 -pid- 时间戳


二.调试方式和命令
1.gdb调试时可以查看源代码，是因为会记录源代码的目录，如果找不到源代码，则会在当前的目录找源代码。也可以手动指定源码的路径。有两种情况：
  （1）如果找不到原文件，也可以调试，不过只能显示文件名和行数，不能显示具体的代码
  （2）可以把core文件下载到有源码的机器，或者把源码下载到有core的文件
  测试gdb是否找到了源码：敲命令 l ，是否有列出代码
  
2.调试coredump文件
    gdb executable-file core-file

    例如调试a.out产生的core文件：core.a.out.24424:
	gdb ./a.out core.a.out.24424

3.绑定进程调试，两种方式:
   1. gdb executable-file PID
   2. gdb executable-file ,然后在gdb界面手动绑定: attach PID

   绑定后，进程被gdb挂起，进程状态为t
   用r或者c让进程进入运行状态
   在运行状态挂起，回到gdb界面：ctrl-c
   用detach解绑当前绑定的进程

4.常用命令
   调试coredump：
    bt(backtrace) :当前函数栈帧   
	f(frame) num :选择栈帧
    p(print) valName:打印变量值,也可以直接输出变量的地址： p &valName，或者输出当前对象的地址和所有成员：p this  ,  p *this
	l(list)  :查看源码
    l(list) 行号或者函数名：列出源码  或者filename:linenum
	i(info) locals:查看当前栈帧的所有局部变量的值
	i(info) registers:显示所有寄存器的值
	i(info) breakpoints
    i(info) program : 查看进程状态
   
   调试代码：
   start:开始调试
   r(run):重头开始连续执行
   b(break):行号或者函数名：设置断点
   s(step):单步执行
      
info , enable、disable 和 delete break
	  
	 
   